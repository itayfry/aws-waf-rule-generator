import { generateObject } from 'ai';
import { z } from 'zod';
import { getModel } from '../utils/config.js';

// Schema for extracted exploit context
export const ExploitContextSchema = z.object({
  attackPatterns: z.array(z.string()).describe('Attack patterns like "POST to /_api/web/", "serialized payload in body"'),
  targetEndpoints: z.array(z.string()).describe('Target URL paths like "/_api/web/GetFileById", "/_vti_bin/client.svc"'),
  payloadSignatures: z.array(z.string()).describe('Payload signatures like "__VIEWSTATE", "ObjectStateFormatter", "${jndi:ldap"'),
  httpMethods: z.array(z.string()).describe('HTTP methods used in the attack like "POST", "PUT", "GET"'),
  headers: z.array(z.string()).describe('Notable HTTP headers used in the attack'),
  queryParameters: z.array(z.string()).describe('Query parameters that may indicate exploit attempts'),
  bodyPatterns: z.array(z.string()).describe('Patterns found in request bodies'),
  summary: z.string().describe('Brief summary of the exploit technique'),
});

export type ExploitContext = z.infer<typeof ExploitContextSchema>;

// Default empty context when no data is available
const EMPTY_CONTEXT: ExploitContext = {
  attackPatterns: [],
  targetEndpoints: [],
  payloadSignatures: [],
  httpMethods: [],
  headers: [],
  queryParameters: [],
  bodyPatterns: [],
  summary: 'No exploit context available',
};

/**
 * Fetch URL content with timeout and error handling
 */
async function fetchWithTimeout(
  url: string,
  timeoutMs: number = 5000
): Promise<string> {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeoutMs);

  try {
    const response = await fetch(url, {
      signal: controller.signal,
      headers: {
        'User-Agent': 'Mozilla/5.0 (compatible; WAF-Rule-Generator/1.0)',
        Accept: 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
      },
    });

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    const text = await response.text();
    
    // Strip HTML tags and extract text content (basic extraction)
    const textContent = text
      .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
      .replace(/<style\b[^<]*(?:(?!<\/style>)<[^<]*)*<\/style>/gi, '')
      .replace(/<[^>]+>/g, ' ')
      .replace(/\s+/g, ' ')
      .trim();

    // Limit content size to avoid token limits
    return textContent.slice(0, 15000);
  } finally {
    clearTimeout(timeoutId);
  }
}

/**
 * Fetch and analyze exploit example URLs to extract attack patterns
 */
export async function fetchExploitContext(
  urls: string[],
  options: { timeoutMs?: number; skipFetch?: boolean } = {}
): Promise<ExploitContext> {
  const { timeoutMs = 5000, skipFetch = false } = options;

  if (!urls.length) {
    return EMPTY_CONTEXT;
  }

  // Skip actual fetching in test mode or when URLs are unavailable
  if (skipFetch) {
    return EMPTY_CONTEXT;
  }

  // Fetch all URLs in parallel with individual error handling
  const fetchResults = await Promise.allSettled(
    urls.map((url) => fetchWithTimeout(url, timeoutMs))
  );

  // Collect successful fetches
  const successfulContent: string[] = [];
  const failedUrls: string[] = [];

  fetchResults.forEach((result, index) => {
    if (result.status === 'fulfilled' && result.value) {
      successfulContent.push(`--- Source: ${urls[index]} ---\n${result.value}`);
    } else {
      failedUrls.push(urls[index]);
    }
  });

  if (successfulContent.length === 0) {
    console.warn(`Failed to fetch any exploit URLs: ${failedUrls.join(', ')}`);
    return EMPTY_CONTEXT;
  }

  const combinedContent = successfulContent.join('\n\n');

  try {
    // Use LLM to extract structured exploit patterns
    const { object: exploitContext } = await generateObject({
      model: getModel('mini'),
      schema: ExploitContextSchema,
      system: `You are a security researcher analyzing vulnerability reports and exploit articles.
Your task is to extract technical details that can be used to create WAF (Web Application Firewall) rules.

Focus on extracting:
1. Specific URL paths and endpoints targeted by the exploit
2. HTTP methods used (GET, POST, PUT, etc.)
3. Payload signatures - distinctive strings or patterns in the attack payload
4. HTTP headers that are manipulated or required for the exploit
5. Query parameters or body patterns used in the attack

Be precise and specific - these patterns will be used to generate WAF blocking rules.
If information is not available, return empty arrays for those fields.`,
      prompt: `Extract exploit technical details from these security articles:\n\n${combinedContent}`,
    });

    return exploitContext;
  } catch (error) {
    console.error('Failed to extract exploit context:', error);
    return EMPTY_CONTEXT;
  }
}

/**
 * Create a simplified context when full fetching is not possible
 */
export function createBasicContext(
  description: string,
  product: string
): ExploitContext {
  // Extract basic patterns from the CVE description
  const patterns: Partial<ExploitContext> = {
    attackPatterns: [],
    targetEndpoints: [],
    payloadSignatures: [],
    httpMethods: [],
    headers: [],
    queryParameters: [],
    bodyPatterns: [],
    summary: description,
  };

  // Common product-specific patterns
  const productPatterns: Record<string, Partial<ExploitContext>> = {
    sharepoint: {
      targetEndpoints: ['/_api/', '/_vti_bin/', '/_layouts/'],
      httpMethods: ['POST', 'PUT'],
    },
    confluence: {
      targetEndpoints: ['/setup/', '/server-info.action', '/json/'],
      httpMethods: ['GET', 'POST'],
    },
    log4j: {
      payloadSignatures: ['${jndi:', '${lower:', '${upper:', '${env:'],
      headers: ['User-Agent', 'X-Api-Version', 'X-Forwarded-For'],
    },
    fortios: {
      targetEndpoints: ['/remote/', '/sslvpn/'],
      httpMethods: ['GET', 'POST'],
    },
  };

  // Apply product-specific patterns if available
  const productKey = Object.keys(productPatterns).find((key) =>
    product.toLowerCase().includes(key)
  );

  if (productKey) {
    Object.assign(patterns, productPatterns[productKey]);
  }

  return patterns as ExploitContext;
}
